namespace Main;

// https://journal.stuffwithstuff.com/2015/09/07/what-the-hero-sees/

public class Shadow
{
    public float start;
    public float end;
    
    public Shadow(float start, float end)
    {
        this.start = start;
        this.end = end;
    }
    // public Shadow(int row, int col)
    // {
    //     this.start = (float)col / ((float)row + 2);
    //     this.end = ((float)col + 1) / ((float)row + 1);
    // }

    public bool Contains(Shadow projection)
    {
        return (start <= projection.start) && (end >= projection.end);
    }

    // public void Unify(float start, float end)
    // {
    //     if (start <= this.end)
    //     {
    //         this.end = Math.Max(this.end, end);
    //     }

    //     if (this.start <= end)
    //     {
    //         this.start = Math.Min(this.start, start);
    //     }
    // }
}

public class ShadowLine
{
    List<Shadow> shadows = new List<Shadow>();

    public bool IsInShadow(Shadow projection)
    {
        foreach (Shadow shadow in shadows)
        {
            if (shadow.Contains(projection)) { return true; }
        }
        return false;
    }

    // public bool IsFullShadow
    // {
    //     get { return (shadows.Count == 1 && shadows[0].start == 0 && shadows[0].end == 1); }
    // }

    public bool Add(Shadow shadow)
    {
        // Find out where to put the new shadow in the list
        int index = 0;
        for (; index < shadows.Count; index++)
        {
            // Stop when hitting the insertion point
            if (shadows[index].start >= shadow.start) { break; }
        }

        // Check if the new shadow overlaps the previous shadow
        Shadow overlappingPrev = null;
        if (index > 0 && shadows[index - 1].end > shadow.start)
        {
            overlappingPrev = shadows[index - 1];
        }

        // Check if the new shadow overlaps the next shadow
        Shadow overlappingNext = null;
        if (index < shadows.Count && shadows[index].start < shadow.end)
        {
            overlappingNext = shadows[index];
        }

        // Overlaps with the next shadow
        if (overlappingNext != null)
        {

            // Overlaps with both shadows so unify one and delete the other
            if (overlappingPrev != null)
            {
                overlappingPrev.end = overlappingNext.end;
                shadows.RemoveAt(index);
            }

            // Overlaps with only the next one so unify with that
            else 
            {
                overlappingNext.start = shadow.start;
            }
        }

        // Does not overlap with the next shadow
        else
        {

            // Overlaps with only the previous one so unify with that
            if (overlappingPrev != null)
            {
                overlappingPrev.end = shadow.end;
            }

            // Does not overlap with anything so insert to the list
            else
            {
                shadows.Insert(index, shadow);
            }
        }
    return (shadows.Count == 1) && (shadows[0].start == 0) && (shadows[0].end == 1.0);
    }


}

// 1. Walk over overy octant
// 2. Walk every tile in an octant
// 3. Update visibility of the current tile
// 4. Update the shadow line if the tile is opaque
public static class FieldOfView
{
    private static List<Shadow> shadows = new List<Shadow>();

    private static Vec2 TransformOctant(Vec2 origin, int row, int col, int octant)
    {
        switch (octant)
        {
            case 0: return new Vec2(origin.x + col, origin.y + row);
            case 1: return new Vec2(origin.x + col, origin.y - row);
            case 2: return new Vec2(origin.x - col, origin.y + row);
            case 3: return new Vec2(origin.x - col, origin.y - row);
            case 4: return new Vec2(origin.x + row, origin.y + col);
            case 5: return new Vec2(origin.x + row, origin.y - col);
            case 6: return new Vec2(origin.x - row, origin.y + col);
            case 7: return new Vec2(origin.x - row, origin.y - col);
        }
        return null;
    }

    public static void RefreshVisibility(Map map, Vec2 origin)
    {
        map.SetVisible(origin);
        
        for (int octant = 0; octant < 8; octant++)
        {
            RefreshOctant(map, origin, octant);
        }
    }

    private static void RefreshOctant(Map map, Vec2 origin, int octant, int maxRows = 999)
    {
        //ShadowLine line = new ShadowLine();
        bool fullShadow = false;

        shadows.Clear();

        int row = 1;
            int col = 0;
        for (; row < maxRows; row++)
        {

            // Set current position
            //Vec2 pos = origin + TransformOctant(row, 0, octant);

            // Stop when going out of bounds
            if (!map.InBounds(TransformOctant(origin, row, 0, octant))) { break; }

            // Loop through columns
            for (; col <= row; col++)
            {
                // Set the current position
                Vec2 pos = TransformOctant(origin, row, col, octant);

                // Stop when going out of bounds
                if (!map.InBounds(pos)) { break; }
                
                map.debugMapFov[pos.x, pos.y] = (char)('0' + octant);

                // if (fullShadow)
                // {
                //     tiles[pos].isVisible = false;
                // }
                // else
                if (!fullShadow)
                {
                    Shadow projection = GetProjection(row, col);
                    //Shadow projection = new Shadow(row, col);

                    // Set the visibility of the current tile
                    bool visible = !IsInShadow(projection);
                    //map.SetVisible(pos, visible);
                    if (visible) { map.SetVisible(pos); }
                    //visible = true;
                    //tiles[pos].isVisible = visible;

                    // Add any opaque tile to the shadow map
                    //if (visible && map.GetBlocking(pos))
                    if (map.GetBlocking(pos))
                    {
                        //fullShadow = line.Add(projection);
                        //fullShadow = line.IsFullShadow;
                        map.debugMapFov[pos.x, pos.y] = (char)('x');
                        fullShadow = AddShadow(projection);
                    }
                }

            }
        }

        //Shadow endprojection = new Shadow(row, col);
        //Logger.Err(octant.ToString() + " " + endprojection.start.ToString() + " " + endprojection.end.ToString());
    }

    private static Shadow GetProjection(int row, int col)
    {
        float topLeft = col / (row + 2);
        float bottomRight = (col + 1) / (row + 1);
        return new Shadow(topLeft, bottomRight);
    }
    
    private static bool IsInShadow(Shadow projection)
    {
        foreach (Shadow shadow in shadows)
        {
            if (shadow.Contains(projection)) { return true; }
        }
        return false;
    }
    
    private static bool AddShadow(Shadow shadow)
    {
        // Find out where to put the new shadow in the list
        int index = 0;
        for (index = 0; index < shadows.Count; index++)
        {
            // Stop when hitting the insertion point
            if (shadows[index].start > shadow.start) { break; }
        }

        // Check if the new shadow overlaps the previous shadow
        Shadow overlappingPrev = null;
        if ((index > 0) && (shadows[index - 1].end > shadow.start))
        {
            overlappingPrev = shadows[index - 1];
        }

        // Check if the new shadow overlaps the next shadow
        Shadow overlappingNext = null;
        if ((index < shadows.Count) && (shadows[index].start < shadow.end))
        {
            overlappingNext = shadows[index];
        }

        // Overlaps with the next shadow
        if (overlappingNext != null)
        {

            // Overlaps with both shadows so unify one and delete the other
            if (overlappingPrev != null)
            {
                overlappingPrev.end = overlappingNext.end;
                shadows.RemoveAt(index);
            }

            // Overlaps with only the next one so unify with that
            else 
            {
                overlappingNext.start = shadow.start;
            }
        }

        // Does not overlap with the next shadow
        else
        {

            // Overlaps with only the previous one so unify with that
            if (overlappingPrev != null)
            {
                overlappingPrev.end = shadow.end;
            }

            // Does not overlap with anything so insert to the list
            else
            {
                shadows.Insert(index, shadow);
            }
        }

        // Return true if shadowing everything
        return (shadows.Count == 1) && (shadows[0].start == 0) && (shadows[0].end == 1.0);
    }
}
